import pandas as pd
import ta  # Library for calculating technical indicators
from sklearn.ensemble import RandomForestRegressor, RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import r2_score, mean_squared_error, mean_absolute_error, classification_report, accuracy_score

# Step 1: Load data from the CSV file
data = pd.read_csv('bitcoin-nupl.csv')

# Step 2: Convert the 'DateTime' column to datetime type
data['DateTime'] = pd.to_datetime(data['DateTime'])

# Step 3: Add the NUPL category
def categorize_nupl(nupl):
    if nupl <= 0.2:
        return 'Low'
    elif 0.2 < nupl <= 0.6:
        return 'Medium'
    else:
        return 'High'

data['NUPL Category'] = data['NUPL Value'].apply(categorize_nupl)

# Step 4: Calculate additional columns
# 14-day change
data['14-day chg'] = data['BTC price (NUPL)'].pct_change(periods=14) * 100

# Future price in 7 and 14 days
data['Future Price (7D)'] = data['BTC price (NUPL)'].shift(-7)
data['Future Price (14D)'] = data['BTC price (NUPL)'].shift(-14)

# Percentage change in future price over 7 and 14 days
data['Fut_Chg_7D'] = ((data['Future Price (7D)'] - data['BTC price (NUPL)']) / data['BTC price (NUPL)']) * 100
data['Fut_Chg_14D'] = ((data['Future Price (14D)'] - data['BTC price (NUPL)']) / data['BTC price (NUPL)']) * 100

# Volatility over 7, 14, and 21 days
data['Vol_7D'] = data['BTC price (NUPL)'].rolling(window=7).std()
data['Vol_14D'] = data['BTC price (NUPL)'].rolling(window=14).std()
data['Vol_21D'] = data['BTC price (NUPL)'].rolling(window=21).std()

# Moving averages over 7, 14, and 21 days
data['SMA_7'] = data['BTC price (NUPL)'].rolling(window=7).mean()
data['SMA_14'] = data['BTC price (NUPL)'].rolling(window=14).mean()
data['SMA_21'] = data['BTC price (NUPL)'].rolling(window=21).mean()

# RSI over 7, 14, and 21 days
data['RSI_7'] = ta.momentum.RSIIndicator(data['BTC price (NUPL)'], window=7).rsi()
data['RSI_14'] = ta.momentum.RSIIndicator(data['BTC price (NUPL)'], window=14).rsi()
data['RSI_21'] = ta.momentum.RSIIndicator(data['BTC price (NUPL)'], window=21).rsi()

# Remove NaN values generated by technical indicators
data.dropna(inplace=True)

# Round all numeric values to 3 decimal places
cols_to_round = ['14-day chg', 'Fut_Chg_7D', 'Fut_Chg_14D', 'Vol_7D', 'Vol_14D', 'Vol_21D', 'SMA_7', 'SMA_14', 'SMA_21', 'RSI_7', 'RSI_14', 'RSI_21']
data[cols_to_round] = data[cols_to_round].round(3)

# Step 5: Filter data for the range from 01/01/2025 to 31/01/2025
start_date = '2025-01-01'
end_date = '2025-01-31'
data_filtered = data[(data['DateTime'] >= start_date) & (data['DateTime'] <= end_date)]

# Step 6: Display the filtered data
print(f"Filtered data from {start_date} to {end_date}:")
print(data_filtered[['DateTime', 'NUPL Value', 'NUPL Category', 'BTC price (NUPL)', '14-day chg',
                     'Fut_Chg_7D', 'Fut_Chg_14D', 'Vol_7D', 'Vol_14D', 'Vol_21D', 'SMA_7', 'SMA_14',
                     'SMA_21', 'RSI_7', 'RSI_14', 'RSI_21']])

# Step 7: Descriptive statistics (rounded to 3 decimal places)
print("\nDescriptive statistics:")
print(data_filtered[['NUPL Value', 'BTC price (NUPL)', '14-day chg', 'Fut_Chg_7D', 'Fut_Chg_14D',
                     'Vol_7D', 'Vol_14D', 'Vol_21D', 'SMA_7', 'SMA_14', 'SMA_21', 'RSI_7', 'RSI_14', 'RSI_21']].describe().round(3))

# Distribution of NUPL categories
print("\nDistribution of NUPL categories:")
print(data_filtered['NUPL Category'].value_counts())

# Check for missing values
print("\nMissing values per column:")
print(data_filtered.isnull().sum())

# Step 8: Calculate the Pearson correlation matrix
correlation_matrix = data_filtered[['NUPL Value', 'BTC price (NUPL)', '14-day chg', 'Fut_Chg_7D', 'Fut_Chg_14D',
                                    'Vol_7D', 'Vol_14D', 'Vol_21D', 'SMA_7', 'SMA_14', 'SMA_21', 'RSI_7', 'RSI_14', 'RSI_21']].corr(method='pearson')

# Display the correlation matrix
print("\nPearson correlation matrix:")
print(correlation_matrix)

# Filtering the most significant negative correlations
negative_correlations = correlation_matrix[correlation_matrix < 0].stack()
significant_negative_correlations = negative_correlations[negative_correlations < -0.5]  # Threshold of -0.5 for significance
print("\nSignificant negative correlations:")
print(significant_negative_correlations)

# ------------------------------------------------------------------------------------
# Step 9: Random Forest Regressor to predict Fut_Chg_14D
# ------------------------------------------------------------------------------------

# Feature selection (X) based on significant negative correlations
X_reg = data_filtered[['BTC price (NUPL)', 'NUPL Value', 'SMA_7', 'SMA_14', 'SMA_21', 'RSI_14', 'RSI_21']]

# Target variable (y)
y_reg = data_filtered['Fut_Chg_14D']

# Split the data into training and test sets
X_train_reg, X_test_reg, y_train_reg, y_test_reg = train_test_split(X_reg, y_reg, test_size=0.2, random_state=42)

# Train the Random Forest Regressor model
rf_regressor = RandomForestRegressor(n_estimators=100, random_state=42)
rf_regressor.fit(X_train_reg, y_train_reg)

# Predict on the test set
y_pred_reg = rf_regressor.predict(X_test_reg)

# Evaluate the model's performance
print("\nRandom Forest Regressor model performance:")
print(f"RÂ²: {r2_score(y_test_reg, y_pred_reg):.3f}")
print(f"MSE: {mean_squared_error(y_test_reg, y_pred_reg):.3f}")
print(f"MAE: {mean_absolute_error(y_test_reg, y_pred_reg):.3f}")

# Feature importance
importances_reg = rf_regressor.feature_importances_
feature_importance_reg = pd.DataFrame({'Feature': X_reg.columns, 'Importance': importances_reg})
feature_importance_reg = feature_importance_reg.sort_values(by='Importance', ascending=False)
print("\nFeature importance for the Regressor model:")
print(feature_importance_reg)

# ------------------------------------------------------------------------------------
# Step 10: Random Forest Classifier to predict NUPL Category
# ------------------------------------------------------------------------------------

# Feature selection (X)
X_clf = data_filtered[['BTC price (NUPL)', '14-day chg', 'SMA_7', 'SMA_14', 'SMA_21', 'RSI_7', 'RSI_14', 'RSI_21']]

# Target variable (y)
y_clf = data_filtered['NUPL Category']

# Split the data into training and test sets
X_train_clf, X_test_clf, y_train_clf, y_test_clf = train_test_split(X_clf, y_clf, test_size=0.2, random_state=42)

# Train the Random Forest Classifier model
rf_classifier = RandomForestClassifier(n_estimators=100, random_state=42)
rf_classifier.fit(X_train_clf, y_train_clf)

# Predict on the test set
y_pred_clf = rf_classifier.predict(X_test_clf)

# Evaluate the model's performance
print("\nRandom Forest Classifier model performance:")
print("Classification report:")
print(classification_report(y_test_clf, y_pred_clf))
print(f"Accuracy: {accuracy_score(y_test_clf, y_pred_clf):.3f}")

# Feature importance
importances_clf = rf_classifier.feature_importances_
feature_importance_clf = pd.DataFrame({'Feature': X_clf.columns, 'Importance': importances_clf})
feature_importance_clf = feature_importance_clf.sort_values(by='Importance', ascending=False)
print("\nFeature importance for the Classifier model:")
print(feature_importance_clf)

# ------------------------------------------------------------------------------------
# Step 11: Save the filtered data to a new CSV file
# ------------------------------------------------------------------------------------
output_file = 'nupl_analysis_january_2025.csv'
data_filtered.to_csv(output_file, index=False)
print(f"\nFiltered data has been saved to '{output_file}'.")

